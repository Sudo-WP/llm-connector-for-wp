#!/usr/bin/env python3
"""
WordPress LLM Connector MCP Server

An MCP server that connects Claude Code to a WordPress site
via the WP LLM Connector plugin REST API.

Usage:
    python wordpress_mcp.py

Configuration via environment variables:
    WP_LLM_SITE_URL  - WordPress site URL (e.g., https://example.com)
    WP_LLM_API_KEY   - API key generated by the WP LLM Connector plugin
"""

import json
import os
import sys
from typing import Optional, Dict, Any
from enum import Enum
from contextlib import asynccontextmanager

import httpx
from pydantic import BaseModel, Field, ConfigDict
from mcp.server.fastmcp import FastMCP

# ========================================
# Configuration
# ========================================

SITE_URL = os.environ.get("WP_LLM_SITE_URL", "").rstrip("/")
API_KEY = os.environ.get("WP_LLM_API_KEY", "")
BASE_PATH = "/wp-json/wp-llm-connector/v1"
REQUEST_TIMEOUT = 30.0
USER_AGENT = "WP-LLM-Connector-MCP/1.0"


# ========================================
# HTTP Client (shared)
# ========================================

async def wp_api_request(endpoint: str, params: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
    """Make an authenticated request to the WordPress LLM Connector API.

    Args:
        endpoint: API endpoint path (e.g., '/site-info').
        params: Optional query parameters.

    Returns:
        Parsed JSON response as a dictionary.

    Raises:
        ValueError: If configuration is missing.
        httpx.HTTPStatusError: If the API returns an error status.
    """
    if not SITE_URL:
        raise ValueError(
            "WP_LLM_SITE_URL environment variable is not set. "
            "Set it to your WordPress site URL (e.g., https://example.com)."
        )
    if not API_KEY:
        raise ValueError(
            "WP_LLM_API_KEY environment variable is not set. "
            "Generate an API key in WordPress > Settings > LLM Connector."
        )

    url = f"{SITE_URL}{BASE_PATH}{endpoint}"
    headers = {
        "X-WP-LLM-API-Key": API_KEY,
        "User-Agent": USER_AGENT,
        "Accept": "application/json",
    }

    async with httpx.AsyncClient(timeout=REQUEST_TIMEOUT) as client:
        response = await client.get(url, headers=headers, params=params)
        response.raise_for_status()
        return response.json()


def handle_api_error(e: Exception) -> str:
    """Format API errors into actionable messages."""
    if isinstance(e, ValueError):
        return f"Configuration error: {e}"
    if isinstance(e, httpx.HTTPStatusError):
        status = e.response.status_code
        if status == 401:
            return "Authentication failed. Check that your WP_LLM_API_KEY is correct and the key is active in WordPress > Settings > LLM Connector."
        if status == 403:
            return "Access denied. The API key may be revoked, or the connector is disabled in WordPress settings."
        if status == 404:
            return f"Endpoint not found. Verify the WP LLM Connector plugin is active and the endpoint exists. URL: {e.request.url}"
        if status == 429:
            return "Rate limit exceeded. Wait a moment and try again, or increase the rate limit in WordPress > Settings > LLM Connector."
        return f"API error (HTTP {status}): {e.response.text[:200]}"
    if isinstance(e, httpx.ConnectError):
        return f"Cannot connect to {SITE_URL}. Check that the URL is correct and the site is accessible."
    if isinstance(e, httpx.TimeoutException):
        return f"Request timed out after {REQUEST_TIMEOUT}s. The site may be slow or unresponsive."
    return f"Unexpected error: {type(e).__name__}: {e}"


def format_json(data: Any) -> str:
    """Format data as pretty-printed JSON."""
    return json.dumps(data, indent=2, ensure_ascii=False)


def format_plugins_markdown(plugins: list) -> str:
    """Format plugin list as readable Markdown."""
    active = [p for p in plugins if p.get("active")]
    inactive = [p for p in plugins if not p.get("active")]

    lines = [f"# Plugins ({len(plugins)} total, {len(active)} active)\n"]

    if active:
        lines.append("## Active Plugins\n")
        for p in sorted(active, key=lambda x: x.get("name", "")):
            lines.append(f"- **{p['name']}** v{p.get('version', '?')} — {p.get('description', '')[:80]}")

    if inactive:
        lines.append(f"\n## Inactive Plugins ({len(inactive)})\n")
        for p in sorted(inactive, key=lambda x: x.get("name", "")):
            lines.append(f"- ~~{p['name']}~~ v{p.get('version', '?')}")

    return "\n".join(lines)


def format_site_info_markdown(data: dict) -> str:
    """Format site info as readable Markdown."""
    return f"""# {data.get('site_name', 'WordPress Site')}

- **URL**: {data.get('site_url', 'N/A')}
- **WordPress**: {data.get('wp_version', '?')}
- **PHP**: {data.get('php_version', '?')}
- **Language**: {data.get('language', '?')}
- **Timezone**: {data.get('timezone', '?')}
- **Multisite**: {'Yes' if data.get('is_multisite') else 'No'}
- **Charset**: {data.get('charset', '?')}"""


def format_system_status_markdown(data: dict) -> str:
    """Format system status as readable Markdown."""
    server = data.get("server", {})
    wp = data.get("wordpress", {})
    db = data.get("database", {})
    fs = data.get("filesystem", {})

    return f"""# System Status

## Server
- **Software**: {server.get('software', '?')}
- **PHP**: {server.get('php_version', '?')}
- **MySQL**: {server.get('mysql_version', '?')}
- **Memory Limit**: {server.get('memory_limit', '?')}
- **Max Execution Time**: {server.get('max_execution_time', '?')}s
- **Upload Max**: {server.get('upload_max_filesize', '?')}

## WordPress
- **Version**: {wp.get('version', '?')}
- **Debug Mode**: {'On' if wp.get('debug_mode') else 'Off'}
- **WP Memory Limit**: {wp.get('memory_limit', '?')}

## Database
- **Tables**: {db.get('tables_count', '?')}
- **Size**: {db.get('database_size', '?')}

## Filesystem
- **Uploads Writable**: {'✅' if fs.get('uploads_writable') else '❌'}
- **Content Writable**: {'✅' if fs.get('content_writable') else '❌'}"""


# ========================================
# Response Format
# ========================================

class ResponseFormat(str, Enum):
    """Output format for tool responses."""
    MARKDOWN = "markdown"
    JSON = "json"


# ========================================
# MCP Server
# ========================================

mcp = FastMCP("wordpress_mcp")


# ========================================
# Tools
# ========================================

class WpHealthInput(BaseModel):
    """Input for health check (no parameters needed)."""
    model_config = ConfigDict(extra="forbid")


@mcp.tool(
    name="wp_health_check",
    annotations={
        "title": "WordPress Health Check",
        "readOnlyHint": True,
        "destructiveHint": False,
        "idempotentHint": True,
        "openWorldHint": True,
    },
)
async def wp_health_check(params: WpHealthInput) -> str:
    """Check if the WordPress site and LLM Connector API are reachable.

    This is a quick connectivity test that does not require authentication.
    Use this first to verify the connection before making other API calls.

    Returns:
        str: JSON with status and timestamp if healthy, or error message.
    """
    try:
        # Health endpoint doesn't require auth.
        url = f"{SITE_URL}{BASE_PATH}/health"
        async with httpx.AsyncClient(timeout=REQUEST_TIMEOUT) as client:
            response = await client.get(url, headers={"User-Agent": USER_AGENT})
            response.raise_for_status()
            data = response.json()
        return format_json({"status": "connected", "site": SITE_URL, **data})
    except Exception as e:
        return handle_api_error(e)


class WpSiteInfoInput(BaseModel):
    """Input for site information retrieval."""
    model_config = ConfigDict(extra="forbid")

    response_format: ResponseFormat = Field(
        default=ResponseFormat.MARKDOWN,
        description="Output format: 'markdown' for readable or 'json' for structured data",
    )


@mcp.tool(
    name="wp_get_site_info",
    annotations={
        "title": "Get WordPress Site Information",
        "readOnlyHint": True,
        "destructiveHint": False,
        "idempotentHint": True,
        "openWorldHint": True,
    },
)
async def wp_get_site_info(params: WpSiteInfoInput) -> str:
    """Get basic information about the WordPress site.

    Returns site name, URL, WordPress version, PHP version, language,
    timezone, and multisite status.

    Args:
        params: Contains response_format (markdown or json).

    Returns:
        str: Site information in the requested format.
    """
    try:
        data = await wp_api_request("/site-info")
        if params.response_format == ResponseFormat.JSON:
            return format_json(data)
        return format_site_info_markdown(data)
    except Exception as e:
        return handle_api_error(e)


class WpPluginsInput(BaseModel):
    """Input for plugin list retrieval."""
    model_config = ConfigDict(extra="forbid")

    response_format: ResponseFormat = Field(
        default=ResponseFormat.MARKDOWN,
        description="Output format: 'markdown' for readable or 'json' for structured data",
    )
    active_only: bool = Field(
        default=False,
        description="If true, only return active plugins",
    )


@mcp.tool(
    name="wp_list_plugins",
    annotations={
        "title": "List WordPress Plugins",
        "readOnlyHint": True,
        "destructiveHint": False,
        "idempotentHint": True,
        "openWorldHint": True,
    },
)
async def wp_list_plugins(params: WpPluginsInput) -> str:
    """List all plugins installed on the WordPress site.

    Returns plugin name, version, author, description, and active status
    for each plugin. Can filter to show only active plugins.

    Args:
        params: Contains response_format and active_only filter.

    Returns:
        str: Plugin list in the requested format.
    """
    try:
        data = await wp_api_request("/plugins")
        if params.active_only:
            data = [p for p in data if p.get("active")]
        if params.response_format == ResponseFormat.JSON:
            return format_json(data)
        return format_plugins_markdown(data)
    except Exception as e:
        return handle_api_error(e)


class WpThemesInput(BaseModel):
    """Input for theme list retrieval."""
    model_config = ConfigDict(extra="forbid")

    response_format: ResponseFormat = Field(
        default=ResponseFormat.JSON,
        description="Output format: 'markdown' for readable or 'json' for structured data",
    )


@mcp.tool(
    name="wp_list_themes",
    annotations={
        "title": "List WordPress Themes",
        "readOnlyHint": True,
        "destructiveHint": False,
        "idempotentHint": True,
        "openWorldHint": True,
    },
)
async def wp_list_themes(params: WpThemesInput) -> str:
    """List all themes installed on the WordPress site.

    Returns theme name, version, author, and active status.

    Args:
        params: Contains response_format.

    Returns:
        str: Theme list in the requested format.
    """
    try:
        data = await wp_api_request("/themes")
        if params.response_format == ResponseFormat.JSON:
            return format_json(data)
        lines = ["# Themes\n"]
        for t in data:
            active = " **(Active)**" if t.get("active") else ""
            lines.append(f"- **{t.get('name', '?')}** v{t.get('version', '?')}{active} — by {t.get('author', '?')}")
        return "\n".join(lines)
    except Exception as e:
        return handle_api_error(e)


class WpSystemStatusInput(BaseModel):
    """Input for system status retrieval."""
    model_config = ConfigDict(extra="forbid")

    response_format: ResponseFormat = Field(
        default=ResponseFormat.MARKDOWN,
        description="Output format: 'markdown' for readable or 'json' for structured data",
    )


@mcp.tool(
    name="wp_get_system_status",
    annotations={
        "title": "Get WordPress System Status",
        "readOnlyHint": True,
        "destructiveHint": False,
        "idempotentHint": True,
        "openWorldHint": True,
    },
)
async def wp_get_system_status(params: WpSystemStatusInput) -> str:
    """Get detailed system status of the WordPress server.

    Returns server software, PHP/MySQL versions, memory limits,
    execution limits, database size, and filesystem status.

    Args:
        params: Contains response_format.

    Returns:
        str: System status in the requested format.
    """
    try:
        data = await wp_api_request("/system-status")
        if params.response_format == ResponseFormat.JSON:
            return format_json(data)
        return format_system_status_markdown(data)
    except Exception as e:
        return handle_api_error(e)


class WpUserCountInput(BaseModel):
    """Input for user count retrieval."""
    model_config = ConfigDict(extra="forbid")


@mcp.tool(
    name="wp_get_user_count",
    annotations={
        "title": "Get WordPress User Statistics",
        "readOnlyHint": True,
        "destructiveHint": False,
        "idempotentHint": True,
        "openWorldHint": True,
    },
)
async def wp_get_user_count(params: WpUserCountInput) -> str:
    """Get user statistics for the WordPress site.

    Returns total user count and breakdown by role.

    Returns:
        str: JSON with user count data.
    """
    try:
        data = await wp_api_request("/user-count")
        return format_json(data)
    except Exception as e:
        return handle_api_error(e)


class WpPostStatsInput(BaseModel):
    """Input for post statistics retrieval."""
    model_config = ConfigDict(extra="forbid")


@mcp.tool(
    name="wp_get_post_stats",
    annotations={
        "title": "Get WordPress Post Statistics",
        "readOnlyHint": True,
        "destructiveHint": False,
        "idempotentHint": True,
        "openWorldHint": True,
    },
)
async def wp_get_post_stats(params: WpPostStatsInput) -> str:
    """Get content statistics for the WordPress site.

    Returns counts of posts, pages, and other content types,
    broken down by status (published, draft, etc.).

    Returns:
        str: JSON with post statistics data.
    """
    try:
        data = await wp_api_request("/post-stats")
        return format_json(data)
    except Exception as e:
        return handle_api_error(e)


class WpFullDiagnosticsInput(BaseModel):
    """Input for full site diagnostics."""
    model_config = ConfigDict(extra="forbid")


@mcp.tool(
    name="wp_full_diagnostics",
    annotations={
        "title": "Run Full WordPress Diagnostics",
        "readOnlyHint": True,
        "destructiveHint": False,
        "idempotentHint": True,
        "openWorldHint": True,
    },
)
async def wp_full_diagnostics(params: WpFullDiagnosticsInput) -> str:
    """Run a comprehensive diagnostic check on the WordPress site.

    Calls all available endpoints and compiles a full report including
    site info, system status, plugin list, themes, user count, and post stats.
    Use this for a complete overview of the site's health and configuration.

    Returns:
        str: Comprehensive Markdown report of the entire WordPress site.
    """
    sections = []

    endpoints = [
        ("/site-info", "Site Information", format_site_info_markdown),
        ("/system-status", "System Status", format_system_status_markdown),
        ("/plugins", "Plugins", format_plugins_markdown),
    ]

    for endpoint, name, formatter in endpoints:
        try:
            data = await wp_api_request(endpoint)
            sections.append(formatter(data))
        except Exception as e:
            sections.append(f"# {name}\n\n⚠️ Error: {handle_api_error(e)}")

    # Themes, users, posts — simpler formatting.
    simple_endpoints = [
        ("/themes", "Themes"),
        ("/user-count", "User Statistics"),
        ("/post-stats", "Post Statistics"),
    ]

    for endpoint, name in simple_endpoints:
        try:
            data = await wp_api_request(endpoint)
            sections.append(f"# {name}\n\n```json\n{format_json(data)}\n```")
        except Exception as e:
            sections.append(f"# {name}\n\n⚠️ Error: {handle_api_error(e)}")

    return "\n\n---\n\n".join(sections)


# ========================================
# Entry point
# ========================================

if __name__ == "__main__":
    mcp.run()
